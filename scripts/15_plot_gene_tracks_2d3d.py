#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
OmicsCanvas — Gene Tracks (2D/3D)

This script plots a single gene as stacked tracks (2D) or pseudo-3D stacked tracks (3D).
Inputs can include BAM coverage tracks and optional methylation tracks (CG/CHG/CHH).

This file is generated by splitting the original monolithic plotting script into focused tools.
"""

from __future__ import annotations

import argparse
import os
import warnings
import re
import math
from typing import Dict, List, Tuple, Optional, Iterable

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.patches import ConnectionPatch
from matplotlib.collections import LineCollection

# Optional dependency used by user previously; keep import guarded
try:
    import pysam
except Exception as e:  # pragma: no cover
    pysam = None


def _parse_minmax(s: str):
    """Parse 'min,max' into a (float(min), float(max)) tuple.

    Whitespace is ignored. Example: '0,1' or '-2.5, 3'.
    """
    s = s.strip().replace(' ', '')
    parts = s.split(',')
    if len(parts) != 2:
        raise ValueError(f"Expected 'min,max' but got: {s!r}")
    return float(parts[0]), float(parts[1])

# -----------------------------
# Utilities
# -----------------------------
def ensure_dir(p: str) -> None:
    if p and (not os.path.exists(p)):
        os.makedirs(p, exist_ok=True)


def parse_layers(spec: str) -> List[List[str]]:
    """
    "A,B;C,D,E" -> [["A","B"],["C","D","E"]]
    """
    layers: List[List[str]] = []
    if not spec:
        return layers
    for grp in spec.split(";"):
        grp = grp.strip()
        if not grp:
            continue
        items = [x.strip() for x in grp.split(",") if x.strip()]
        if items:
            layers.append(items)
    return layers


def flatten_layers(layers: List[List[str]]) -> List[str]:
    out: List[str] = []
    for g in layers:
        out.extend(g)
    return out


def get_colors(cmap_name: str, n: int):
    cmap = plt.get_cmap(cmap_name, max(int(n), 1))
    return [cmap(i) for i in range(max(int(n), 1))]


def safe_extract_attr(attr: str, key: str) -> Optional[str]:
    # key=VALUE; ...
    m = re.search(rf"{re.escape(key)}=([^;]+)", str(attr))
    return m.group(1) if m else None


# -----------------------------
# GFF3 / gene model
# -----------------------------
def load_gff3(in_gff3: str) -> pd.DataFrame:
    return pd.read_csv(
        in_gff3,
        sep="\t",
        comment="#",
        header=None,
        usecols=[0, 2, 3, 4, 6, 8],
        names=["ch", "ty", "st", "en", "zf", "attr"],
        dtype={"ch": str, "ty": str, "st": int, "en": int, "zf": str, "attr": str},
        low_memory=False,
    )


def build_gene_model(
    gff: pd.DataFrame,
    gene_id: str,
    *,
    gene_keywords: str = "ID",
    exon_keywords: str = "Parent",
    mrna_type: str = "mRNA",
    exon_type: str = "exon",
    cds_type: str = "CDS",
    utr5_type: str = "five_prime_UTR",
    utr3_type: str = "three_prime_UTR",
    distance: int = 1000,
) -> Dict:
    """
    Return a single-gene model dict:
      ch, gene_id, strand, mrna_start, mrna_end, gene_len, distance, window_len
      exon_rel, cds_rel, utr_rel  (relative to mrna_start)
    """
    pat_gene = rf"{re.escape(gene_keywords)}=([^;]+)"
    pat_exon = rf"{re.escape(exon_keywords)}=([^;]+)"

    df = gff.copy()
    # Extract ID for mRNA; Parent for other features
    is_mrna = df["ty"] == mrna_type
    df.loc[is_mrna, "ID"] = df.loc[is_mrna, "attr"].str.extract(pat_gene, expand=False)
    df.loc[~is_mrna, "ID"] = df.loc[~is_mrna, "attr"].str.extract(pat_exon, expand=False)

    one = df[df["ID"] == gene_id].copy()
    if one.empty:
        raise ValueError(f"gene_id not found in GFF3 by {gene_keywords}/{exon_keywords}: {gene_id}")

    mrna = one[one["ty"] == mrna_type]
    if mrna.empty:
        # fallback: if only gene exists
        raise ValueError(f"No {mrna_type} record for gene_id={gene_id}. Please check in_type1 / keywords.")
    ch, ty, st, en, zf, _attr, _id = mrna.iloc[0][["ch", "ty", "st", "en", "zf", "attr", "ID"]].tolist()

    gene_len = int(en) - int(st)
    window_len = 2 * int(distance) + gene_len

    exon_rel: List[Tuple[int, int]] = []
    cds_rel: List[Tuple[int, int]] = []
    utr_rel: List[Tuple[int, int]] = []

    for _, r in one.iterrows():
        t = r["ty"]
        if t == exon_type:
            exon_rel.append((int(r["st"]) - int(st), int(r["en"]) - int(st)))
        elif t == cds_type:
            cds_rel.append((int(r["st"]) - int(st), int(r["en"]) - int(st)))
        elif t in (utr5_type, utr3_type):
            utr_rel.append((int(r["st"]) - int(st), int(r["en"]) - int(st)))

    exon_rel.sort(key=lambda x: x[0])
    cds_rel.sort(key=lambda x: x[0])
    utr_rel.sort(key=lambda x: x[0])

    return dict(
        gene_id=gene_id,
        ch=ch,
        strand=zf,
        mrna_start=int(st),
        mrna_end=int(en),
        gene_len=gene_len,
        distance=int(distance),
        window_len=window_len,
        exon_rel=exon_rel,
        cds_rel=cds_rel,
        utr_rel=utr_rel,
    )


# -----------------------------
# BAM coverage
# -----------------------------
def open_bams(bam_dir: str, bam_files_layers: List[List[str]]) -> Dict[int, Dict[str, "pysam.AlignmentFile"]]:
    if pysam is None:
        raise RuntimeError("pysam is required for BAM plotting. Please `pip install pysam`.")
    bam_dir = bam_dir if bam_dir.endswith("/") else (bam_dir + "/")
    out: Dict[int, Dict[str, "pysam.AlignmentFile"]] = {}
    for gi, files in enumerate(bam_files_layers):
        out[gi] = {}
        for fp in files:
            path = fp if os.path.isabs(fp) else (bam_dir + fp)
            out[gi][fp] = pysam.AlignmentFile(path, "rb")
    return out


def count_coverage_norm(
    bam: "pysam.AlignmentFile",
    ch: str,
    st: int,
    en: int,
    reads_length: int,
    seq_type: str,
) -> np.ndarray:
    # count_coverage returns A,C,G,T arrays
    cov = np.sum(np.array(bam.count_coverage(contig=ch, start=st, stop=en)), axis=0).astype(float)

    mapped = float(getattr(bam, "mapped", 0) or 0)
    if mapped <= 0:
        mapped = 1.0

    # same normalization style as user's script
    if str(seq_type).lower().startswith("pair"):
        cov = cov / float(reads_length) / 2.0 / mapped * 1e8
    else:
        cov = cov / float(reads_length) / mapped * 1e8
    return cov


def build_bam_cov(
    model: Dict,
    bam_files_layers: List[List[str]],
    name_layers: List[List[str]],
    bam_dir: str,
    reads_length: int,
    seq_type: str,
) -> Dict[int, Dict[str, np.ndarray]]:
    """
    Return:
      cov[group_idx][track_label] = np.ndarray(window_len)
    """
    if len(bam_files_layers) != len(name_layers):
        raise ValueError("bam-spec and name-spec must have the same number of ';' groups.")
    for gi in range(len(bam_files_layers)):
        if len(bam_files_layers[gi]) != len(name_layers[gi]):
            raise ValueError(f"Within group {gi}, bam-spec count != name-spec count.")

    bams = open_bams(bam_dir, bam_files_layers)
    cov: Dict[int, Dict[str, np.ndarray]] = {gi: {} for gi in range(len(name_layers))}

    ch = model["ch"]
    st = model["mrna_start"] - model["distance"]
    en = model["mrna_end"] + model["distance"]

    for gi in bams:
        for bam_fp, label in zip(bam_files_layers[gi], name_layers[gi]):
            arr = count_coverage_norm(bams[gi][bam_fp], ch, st, en, reads_length, seq_type)
            cov[gi][label] = arr

    # Close BAM handles (important when many tracks)
    for gi in bams:
        for fp in list(bams[gi].keys()):
            try:
                bams[gi][fp].close()
            except Exception:
                pass

    return cov


# -----------------------------
# Methylation
# -----------------------------
def read_meth_tsv(path: str) -> pd.DataFrame:
    # tolerate header/no header
    df = pd.read_csv(path, sep="\t", header=0)
    cols = [c.lower() for c in df.columns.tolist()]
    if "po" in cols and "me" in cols and "al" in cols:
        # normalize names
        rename = {}
        for c in df.columns:
            cl = c.lower()
            if cl == "po": rename[c] = "po"
            if cl == "me": rename[c] = "me"
            if cl == "al": rename[c] = "al"
            if cl == "name": rename[c] = "name"
        df = df.rename(columns=rename)
        return df
    # no header or unexpected header: re-read with fixed columns
    df = pd.read_csv(path, sep="\t", header=None)
    if df.shape[1] == 4:
        df.columns = ["name", "po", "me", "al"]
    elif df.shape[1] == 3:
        df.columns = ["po", "me", "al"]
    else:
        raise ValueError(f"Unrecognized methylation TSV format: {path} (ncol={df.shape[1]})")
    return df


def load_meth_prefix(
    meth_dir: str,
    prefix: str,
    gene_id: str,
    *,
    drop_me_zero: bool = True,
) -> Dict[str, pd.DataFrame]:
    """
    Return dict ctx -> df (subset to the given gene_id if possible).
    df columns: po, me, al, ratio
    """
    meth_dir = meth_dir if meth_dir.endswith("/") else (meth_dir + "/")
    out: Dict[str, pd.DataFrame] = {}
    for ctx in ["CG", "CHG", "CHH"]:
        path = f"{meth_dir}{prefix}__{ctx}.tsv"
        if not os.path.exists(path):
            raise FileNotFoundError(f"Missing methylation file: {path}")
        df = read_meth_tsv(path)

        if "name" in df.columns:
            uniq_names = df["name"].astype(str).unique()
            df = df[df["name"].astype(str) == str(gene_id)].copy()
            if df.empty and len(uniq_names) > 0:
                preview = ",".join(list(uniq_names[:5]))
                more = "..." if len(uniq_names) > 5 else ""
                warnings.warn(
                    f"[Methylation] No rows matched gene_id='{gene_id}' in file '{path}'. "
                    f"Available name values (first 5): {preview}{more}. "
                    "Check that --gene matches the gene used to export methylation TSVs, "
                    "or export methylation for this gene."
                )

        if df.empty:
            # keep empty with correct columns
            df = pd.DataFrame(columns=["po", "me", "al", "ratio"])

        # coerce
        if "po" in df.columns:
            df["po"] = pd.to_numeric(df["po"], errors="coerce").fillna(-1).astype(int)
        if "me" in df.columns:
            df["me"] = pd.to_numeric(df["me"], errors="coerce").fillna(0).astype(float)
        if "al" in df.columns:
            df["al"] = pd.to_numeric(df["al"], errors="coerce").fillna(0).astype(float)

        if drop_me_zero and "me" in df.columns:
            df = df[df["me"] != 0].copy()

        if "al" in df.columns and "me" in df.columns:
            al = df["al"].astype(float).replace(0.0, np.nan)
            df["ratio"] = (df["me"].astype(float) / al).fillna(0.0)
        else:
            df["ratio"] = 0.0

        out[ctx] = df[["po", "ratio"]].copy()
    return out


def meth_to_array(df: pd.DataFrame, window_len: int) -> np.ndarray:
    """
    df columns: po, ratio
    """
    arr = np.zeros(int(window_len), dtype=float)
    if df is None or df.empty:
        return arr
    po = df["po"].astype(int).to_numpy()
    val = df["ratio"].astype(float).to_numpy()
    mask = (po >= 0) & (po < int(window_len))
    po = po[mask]
    val = val[mask]
    arr[po] = val
    return arr


# -----------------------------
# Linear gene structure
# -----------------------------
def build_gene_legend_handles(model: Dict) -> List[Patch]:
    """
    Only include items that exist (avoid legend entries for missing intron/UTR etc.)
    """
    exon_rel = model["exon_rel"]
    utr_rel = model["utr_rel"]
    cds_rel = model["cds_rel"]

    has_exon = len(exon_rel) > 0
    has_intr = len(exon_rel) > 1  # intron only meaningful if >=2 exons
    has_utr = len(utr_rel) > 0
    has_cds = len(cds_rel) > 0

    handles: List[Patch] = []
    if has_intr:
        handles.append(Patch(facecolor="grey", edgecolor="black", label="intron"))
    if has_utr:
        handles.append(Patch(facecolor="yellowgreen", edgecolor="black", label="UTR"))
    if has_cds:
        handles.append(Patch(facecolor="slateblue", edgecolor="black", label="CDS"))
    if (not has_utr) and has_exon and (not has_cds):
        # rare cases: exon but no CDS/UTR annotations
        handles.append(Patch(facecolor="yellowgreen", edgecolor="black", label="exon"))
    return handles


def plot_gene_structure_linear(ax: plt.Axes, model: Dict, *,
                              colors: Optional[Dict[str, str]] = None,
                              li_po: int = 10,
                              draw_arrow: bool = True):
    """
    Draw gene structure as a thin line + blocks.
    No legend here; use fig.legend(...) outside to avoid overlap.
    """
    if colors is None:
        colors = {
            "intron": "grey",
            "UTR": "yellowgreen",
            "CDS": "slateblue",
            "line": "black",
        }

    dist = model["distance"]
    gene_len = model["gene_len"]
    strand = model["strand"]

    ax.plot([0, gene_len + 2 * dist], [0, 0], color=colors["line"], lw=1, zorder=1)
    # intron backbone
    ax.plot([dist, gene_len + dist], [0, 0], color=colors["intron"], lw=1, zorder=1)

    # UTR and CDS blocks
    for (s1, s2) in model["utr_rel"]:
        ax.fill_between([dist + s1, dist + s2], y1=[0.001, 0.001], y2=-0.001, color=colors["UTR"], lw=0, zorder=2)
    for (s1, s2) in model["cds_rel"]:
        ax.fill_between([dist + s1, dist + s2], y1=[0.001, 0.001], y2=-0.001, color=colors["CDS"], lw=0, zorder=3)

    ax.set_ylim(-0.003, 0.003)
    ax.set_xlim(0 - li_po, gene_len + 2 * dist + li_po)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines["left"].set_visible(False)
    ax.spines["bottom"].set_visible(False)

    if draw_arrow:
        if strand == "+":
            ax.annotate(
                "",
                xy=(gene_len + 2 * dist, 0),
                xytext=(gene_len + 2 * dist - 10, 0),
                arrowprops=dict(facecolor="black", shrink=100),
            )
        elif strand == "-":
            ax.annotate(
                "",
                xy=(0, 0),
                xytext=(10, 0),
                arrowprops=dict(facecolor="black", shrink=100),
            )


# -----------------------------
# Track plotting: linear
# -----------------------------
def plot_one_bam_track(fig, rect: List[float], cov: np.ndarray, label: str, color,
                       *, x_visible: bool, ylim: Optional[Tuple[float, float]] = None,
                       li_po: int = 10) -> plt.Axes:
    ax = fig.add_axes(rect)
    ax.set_facecolor("none")
    ax.patch.set_visible(False)

    ax.fill_between(np.arange(len(cov)), cov, 0, color=color, zorder=5)
    ax.set_xlim(0 - li_po, len(cov) - 1 + li_po)
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    plt.setp(ax.get_xticklabels(), visible=x_visible)

    ax.set_ylabel(label)

    if ylim is not None:
        ax.set_ylim(float(ylim[0]), float(ylim[1]))
    return ax


def plot_one_meth_track(fig, rect: List[float], arrays: Dict[str, np.ndarray], *,
                        prefix: str,
                        layout: str,
                        colors: Dict[str, str],
                        ylabel: str = "mC",
                        show_prefix: bool = True,
                        x_visible: bool = False,
                        ylim: Optional[Tuple[float, float]] = None) -> plt.Axes:
    ax = fig.add_axes(rect)
    ax.set_facecolor("none")
    ax.patch.set_visible(False)

    x = np.arange(len(next(iter(arrays.values()))))
    if layout == "combined":
        # overlay contexts
        ax.bar(x, arrays["CHH"], width=1.0, color=colors["CHH"], alpha=0.65, linewidth=0, zorder=3)
        ax.bar(x, arrays["CHG"], width=1.0, color=colors["CHG"], alpha=0.65, linewidth=0, zorder=4)
        ax.bar(x, arrays["CG"],  width=1.0, color=colors["CG"],  alpha=0.65, linewidth=0, zorder=5)
    else:
        # arrays has one key
        ctx = list(arrays.keys())[0]
        ax.bar(x, arrays[ctx], width=1.0, color=colors[ctx], alpha=0.85, linewidth=0, zorder=5)

    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    plt.setp(ax.get_xticklabels(), visible=x_visible)

    ax.set_ylabel(ylabel)
    if show_prefix:
        ax.text(0.01, 0.82, prefix, transform=ax.transAxes, ha="left", va="top", fontsize=8)

    if ylim is not None:
        ax.set_ylim(float(ylim[0]), float(ylim[1]))
    return ax


def parse_ylim(s: Optional[str]) -> Optional[Tuple[float, float]]:
    if not s:
        return None
    ymin, ymax = str(s).split(",")
    return float(ymin), float(ymax)


def parse_group_ylims(s: Optional[str], n_groups: int) -> Optional[List[Tuple[float, float]]]:
    """
    "0,5;0,10" for each ';' group.
    """
    if not s:
        return None
    parts = [x.strip() for x in s.split(";") if x.strip()]
    if len(parts) != n_groups:
        raise ValueError(f"group-ylims groups mismatch: expect {n_groups} groups, got {len(parts)}")
    out: List[Tuple[float, float]] = []
    for p in parts:
        out.append(parse_ylim(p))  # type: ignore
    return out


def auto_group_ylim(arrs: Iterable[np.ndarray], pad: float = 0.05, default: Tuple[float, float] = (0.0, 1.0)) -> Tuple[float, float]:
    mx = 0.0
    for a in arrs:
        if a is None or len(a) == 0:
            continue
        v = float(np.nanmax(a))
        if v > mx:
            mx = v
    if mx <= 0:
        return default
    return (0.0, mx * (1.0 + pad))


# -----------------------------
# 3D-like positions
# -----------------------------
def get_track_positions_autoscale(
    spec: str,
    *,
    base_left: float = 0.10,
    top_start: float = 0.95,
    width: float = 0.80,
    height: float = 0.12,
    x_off: float = 0.10,
    y_off: float = 0.60,
    layer_gap: float = 0.05,
    right_margin: float = 0.02,
    bottom_margin: float = 0.02,
    auto_scale: bool = True,
) -> Tuple[List[Tuple[str, List[float], int, int]], float, float]:
    """
    Return:
      positions: list of (track_id, [l,b,w,h], group_idx, idx_in_group)
      used_width, used_height
    """
    layers = parse_layers(spec)
    if not layers:
        raise ValueError("spec parses to empty.")

    max_n = max(len(L) for L in layers)
    denom_w = (1.0 + (max_n - 1) * x_off)
    w_max = (1.0 - right_margin - base_left) / denom_w
    if w_max <= 0:
        raise ValueError("Horizontal space insufficient. Reduce x_off/width or margins.")

    used_w = float(width)
    if used_w > w_max:
        if not auto_scale:
            raise ValueError(f"width={width} too large. Max≈{w_max:.4f}")
        used_w = w_max

    mults = [1.0 + (len(L) - 1) * y_off for L in layers]
    gaps = float(layer_gap) * (len(layers) - 1)
    available_y = float(top_start) - float(bottom_margin)
    if available_y <= 0:
        raise ValueError("Vertical space insufficient: top_start must be > bottom_margin.")
    h_max = (available_y - gaps) / float(sum(mults))
    if h_max <= 0:
        raise ValueError("Vertical space insufficient. Reduce y_off/layer_gap/height or increase top_start.")

    used_h = float(height)
    if used_h > h_max:
        if not auto_scale:
            raise ValueError(f"height={height} too large. Max≈{h_max:.4f}")
        used_h = h_max

    positions: List[Tuple[str, List[float], int, int]] = []
    layer_top = float(top_start)
    eps = 1e-9

    for gi, tracks in enumerate(layers):
        n = len(tracks)
        for i, tid in enumerate(tracks):
            l = float(base_left) + i * float(x_off) * used_w
            b = layer_top - used_h - i * float(y_off) * used_h
            rect = [l, b, used_w, used_h]
            if (l < -eps or b < -eps or l + used_w > 1 + eps or b + used_h > 1 + eps):
                raise ValueError(f"Out of bounds in 3D layout: group={gi}, i={i}, rect={rect}")
            positions.append((tid, rect, gi, i))

        span = used_h * (1.0 + (n - 1) * float(y_off))
        layer_top = layer_top - span - float(layer_gap)

    return positions, used_w, used_h


def connect_vertical(xpos: float, ax_upper: plt.Axes, ax_lower: plt.Axes):
    """
    Draw a vertical dashed ConnectionPatch between two axes at shared x (data coord).
    """
    y_bottom_upper = ax_upper.get_ylim()[0]
    y_top_lower = ax_lower.get_ylim()[0]

    fig = ax_upper.figure
    conn = ConnectionPatch(
        xyA=(xpos, y_bottom_upper), coordsA=ax_upper.transData,
        xyB=(xpos, y_top_lower), coordsB=ax_lower.transData,
        linestyle="--", color="grey", linewidth=0.8,
        zorder=1, clip_on=False
    )
    # Make it sit "inside" visually
    conn.set_zorder(-10)
    conn.set_clip_on(False)
    fig.add_artist(conn)


def add_inside_xlines(ax: plt.Axes, xs: List[float], *, color: str = "grey", lw: float = 0.8, ls: str = "--", zorder: int = 1):
    for x in xs:
        ax.plot([x, x], [0, 1], transform=ax.get_xaxis_transform(), color=color, lw=lw, ls=ls, zorder=zorder)


# -----------------------------
# Circle plot helpers
# -----------------------------
def circle_angle_scale(window_len: int) -> float:
    # keep same spirit as user's original: 2*pi / (len*1.02)
    return 2.0 * math.pi / (float(window_len) * 1.02)


def circle_lines_from_array(arr: np.ndarray, r0: float, rlen: float, one: float, *,
                            step: int = 5, scale_max: Optional[float] = None) -> np.ndarray:
    n = len(arr)
    idx = np.arange(0, n, max(int(step), 1))
    vals = arr[idx].astype(float)
    vmax = float(np.nanmax(vals)) if scale_max is None else float(scale_max)
    if not np.isfinite(vmax) or vmax <= 0:
        vmax = 1.0
    h = vals / vmax * float(rlen)

    ang = -float(one) * idx
    c = np.cos(ang)
    s = np.sin(ang)

    x1 = c * float(r0)
    y1 = s * float(r0)
    x2 = c * (float(r0) + h)
    y2 = s * (float(r0) + h)

    segs = np.stack([np.stack([x1, y1], axis=1), np.stack([x2, y2], axis=1)], axis=1)
    return segs


def circle_lines_from_sites(sites: np.ndarray, r0: float, rlen: float, one: float, *,
                            scale_max: float = 1.0) -> np.ndarray:
    if sites.size == 0:
        return np.zeros((0, 2, 2), dtype=float)
    po = sites[:, 0].astype(int)
    hi = sites[:, 1].astype(float)
    vmax = float(scale_max) if float(scale_max) > 0 else 1.0
    h = hi / vmax * float(rlen)

    ang = -float(one) * po
    c = np.cos(ang)
    s = np.sin(ang)

    x1 = c * float(r0)
    y1 = s * float(r0)
    x2 = c * (float(r0) + h)
    y2 = s * (float(r0) + h)

    segs = np.stack([np.stack([x1, y1], axis=1), np.stack([x2, y2], axis=1)], axis=1)
    return segs


def plot_circle_gene_structure(ax: plt.Axes, model: Dict, *, dist: int, r_gene: float = 1.00, ylim_override=None):
    """
    Draw gene structure on a base ring. Keep simple and robust.
    """
    window_len = model["window_len"]
    one = circle_angle_scale(window_len)

    # entire window ring
    idx = np.arange(0, window_len, 1)
    ang = -one * idx
    ax.plot(np.cos(ang) * r_gene, np.sin(ang) * r_gene, lw=1.0, color="black", zorder=1)

    # intron ring segment (gene body region)
    gene_len = model["gene_len"]
    idx2 = np.arange(dist, dist + gene_len, 1)
    ang2 = -one * idx2
    ax.plot(np.cos(ang2) * r_gene, np.sin(ang2) * r_gene, lw=2.0, color="grey", zorder=2)

    # UTR / CDS segments
    for (s1, s2) in model["utr_rel"]:
        idx3 = np.arange(dist + s1, dist + s2, 1)
        ang3 = -one * idx3
        ax.plot(np.cos(ang3) * r_gene, np.sin(ang3) * r_gene, lw=4.0, color="yellowgreen", zorder=3)
    for (s1, s2) in model["cds_rel"]:
        idx4 = np.arange(dist + s1, dist + s2, 1)
        ang4 = -one * idx4
        ax.plot(np.cos(ang4) * r_gene, np.sin(ang4) * r_gene, lw=4.0, color="slateblue", zorder=4)

    # direction arrow
    strand = model["strand"]
    if strand == "+":
        ax.annotate("", xy=(0.996, 0.105), xytext=(0.994, 0.115), arrowprops=dict(facecolor="black", shrink=100))
    elif strand == "-":
        ax.annotate("", xy=(1.0, 0.02), xytext=(1.0, 0.01), arrowprops=dict(facecolor="black", shrink=100))


def plot_circle(
    model: Dict,
    *,
    outpath: str,
    fig_x: float = 10.0,
    fig_y: float = 10.0,
    # methylation
    meth_dir: Optional[str] = None,
    meth_spec: Optional[str] = None,
    meth_layout: str = "combined",          # combined or separate
    cg_color: str = "#FF3030",
    chg_color: str = "#00EE76",
    chh_color: str = "#00BFFF",
    meth_drop_me_zero: bool = True,
    # BAM rings
    bam_cov: Optional[Dict[int, Dict[str, np.ndarray]]] = None,
    name_layers: Optional[List[List[str]]] = None,
    bam_step: int = 10,
    # ring geometry
    ring_start: float = 1.10,
    ring_width: float = 0.20,
    ring_gap: float = 0.08,
    # frame/limits
    keep_frame: bool = True,
    frame_lw: float = 1.0,
    frame_color: str = "black",
    margin: float = 0.15,
    manual_lim: Optional[float] = None,
):
    dist = model["distance"]
    window_len = model["window_len"]
    one = circle_angle_scale(window_len)

    fig = plt.figure(figsize=(fig_x, fig_y))
    ax = fig.add_axes([0.05, 0.05, 0.90, 0.90])

    # base gene ring
    plot_circle_gene_structure(ax, model, dist=dist, r_gene=1.00)

    handles: List[Patch] = []
    handles.extend(build_gene_legend_handles(model))
    # also show down&up boundary
    handles.append(Patch(facecolor="none", edgecolor="black", label="down & up"))

    ring_cursor = float(ring_start)
    max_r = 1.00  # base gene ring

    # 1) Methylation rings
    if meth_dir and meth_spec:
        meth_colors = dict(CG=cg_color, CHG=chg_color, CHH=chh_color)
        prefixes = flatten_layers(parse_layers(meth_spec))
        for prefix in prefixes:
            d = load_meth_prefix(meth_dir, prefix, model["gene_id"], drop_me_zero=meth_drop_me_zero)

            if meth_layout == "combined":
                # overlay three contexts on same ring
                for ctx in ["CHH", "CHG", "CG"]:
                    sites = d[ctx][["po", "ratio"]].to_numpy()
                    segs = circle_lines_from_sites(sites, ring_cursor, ring_width, one, scale_max=1.0)
                    lc = LineCollection(segs, colors=[meth_colors[ctx]], linewidths=0.3)
                    ax.add_collection(lc)
                max_r = max(max_r, ring_cursor + ring_width)
                ring_cursor += ring_width + ring_gap
            else:
                for ctx in ["CHH", "CHG", "CG"]:
                    sites = d[ctx][["po", "ratio"]].to_numpy()
                    segs = circle_lines_from_sites(sites, ring_cursor, ring_width, one, scale_max=1.0)
                    lc = LineCollection(segs, colors=[meth_colors[ctx]], linewidths=0.3)
                    ax.add_collection(lc)
                    max_r = max(max_r, ring_cursor + ring_width)
                    ring_cursor += ring_width + ring_gap

        handles.extend([
            Patch(facecolor=cg_color, edgecolor="none", label="CG"),
            Patch(facecolor=chg_color, edgecolor="none", label="CHG"),
            Patch(facecolor=chh_color, edgecolor="none", label="CHH"),
        ])

    # 2) BAM / RNA rings (spikes)
    if bam_cov is not None and name_layers is not None:
        bam_names = flatten_layers(name_layers)
        bam_colors = get_colors("Set2", len(bam_names))
        for i, nm in enumerate(bam_names):
            # locate group index containing this nm
            arr = None
            for gi, g in bam_cov.items():
                if nm in g:
                    arr = g[nm]
                    break
            if arr is None:
                continue
            segs = circle_lines_from_array(arr, ring_cursor, ring_width, one, step=bam_step, scale_max=None)
            lc = LineCollection(segs, colors=[bam_colors[i]], linewidths=0.25)
            ax.add_collection(lc)
            handles.append(Patch(facecolor=bam_colors[i], edgecolor="none", label=nm))
            max_r = max(max_r, ring_cursor + ring_width)
            ring_cursor += ring_width + ring_gap

    # Cosmetics: keep square frame if requested.
    # By default we auto-scale the axis limits from the outermost ring.
    # If you want consistent borders across many circle plots, set manual_lim.
    if manual_lim is not None:
        lim = float(manual_lim)
    else:
        lim = float(max_r) + float(margin)
    ax.set_xlim(-lim, lim)
    ax.set_ylim(-lim, lim)
    if ylim_override is not None:
        y0, y1 = ylim_override
        ax.set_ylim(float(y0), float(y1))
    ax.set_aspect("equal", adjustable="box")
    ax.set_xticks([])
    ax.set_yticks([])

    if keep_frame:
        for sp in ["top", "right", "left", "bottom"]:
            ax.spines[sp].set_visible(True)
            ax.spines[sp].set_linewidth(float(frame_lw))
            ax.spines[sp].set_color(frame_color)
    else:
        for sp in ["top", "right", "left", "bottom"]:
            ax.spines[sp].set_visible(False)

    ax.set_title(f"gene: {model['gene_id']}")

    # legend outside in the empty margin
    fig.legend(handles=handles, loc="upper left", bbox_to_anchor=(0.92, 0.95), frameon=False)

    fig.savefig(outpath, bbox_inches="tight")
    plt.close(fig)


# -----------------------------
# 2D / 3D plotting
# -----------------------------
def plot_2d(
    model: Dict,
    bam_cov: Dict[int, Dict[str, np.ndarray]],
    name_layers: List[List[str]],
    *,
    outpath: str,
    fig_x: float = 10.0,
    fig_y: float = 7.0,
    cmap: str = "Set2",
    # y limits for bam
    ylim: Optional[str] = None,
    group_ylims: Optional[str] = None,
    share_group_ylim: bool = False,
    # methylation
    meth_dir: Optional[str] = None,
    meth_spec: Optional[str] = None,
    meth_layout: str = "combined",
    meth_ylabel: str = "mC",
    meth_show_prefix: bool = True,
    meth_ylim: Optional[str] = None,
    meth_group_ylims: Optional[str] = None,
    meth_share_group_ylim: bool = False,
    meth_colors: Optional[Dict[str, str]] = None,
    meth_drop_me_zero: bool = True,
    meth_position: str = "after",  # before|after
):
    dist = model["distance"]
    gene_len = model["gene_len"]

    all_bam_tracks = flatten_layers(name_layers)
    bam_colors = get_colors(cmap, len(all_bam_tracks))

    # group ylims for bam
    n_groups = len(name_layers)
    bam_group_ylims = parse_group_ylims(group_ylims, n_groups) if group_ylims else None
    bam_auto: Dict[int, Tuple[float, float]] = {}
    if share_group_ylim:
        for gi, group in enumerate(name_layers):
            arrs = [bam_cov[gi][nm] for nm in group]
            bam_auto[gi] = auto_group_ylim(arrs, pad=0.05, default=(0.0, 1.0))
    if bam_group_ylims is not None:
        for gi, yl in enumerate(bam_group_ylims):
            bam_auto[gi] = yl

    # methylation layers
    meth_groups = parse_layers(meth_spec) if meth_spec else []
    n_mg = len(meth_groups)
    meth_group_yl = parse_group_ylims(meth_group_ylims, n_mg) if (meth_group_ylims and n_mg > 0) else None
    meth_auto: Dict[int, Tuple[float, float]] = {}
    if meth_share_group_ylim and meth_groups and meth_dir:
        for gi, group in enumerate(meth_groups):
            arrs = []
            for prefix in group:
                d = load_meth_prefix(meth_dir, prefix, model["gene_id"], drop_me_zero=meth_drop_me_zero)
                if meth_layout == "combined":
                    for ctx in ["CG", "CHG", "CHH"]:
                        arrs.append(meth_to_array(d[ctx], model["window_len"]))
                else:
                    # per-prefix per-ctx handled later; still compute using max of all
                    for ctx in ["CG", "CHG", "CHH"]:
                        arrs.append(meth_to_array(d[ctx], model["window_len"]))
            meth_auto[gi] = auto_group_ylim(arrs, pad=0.05, default=(0.0, 1.0))
    if meth_group_yl is not None:
        for gi, yl in enumerate(meth_group_yl):
            meth_auto[gi] = yl

    meth_colors = meth_colors or {"CG": "#FF3030", "CHG": "#00EE76", "CHH": "#00BFFF"}

    # Build the final stacked order
    stack_items: List[Tuple[str, Tuple[int, str, str]]] = []
    # ('bam', (group_idx, label, ''))  or ('meth', (group_idx, prefix, ctxmode))
    if meth_position == "before" and meth_groups:
        for gi, group in enumerate(meth_groups):
            for prefix in group:
                if meth_layout == "combined":
                    stack_items.append(("meth", (gi, prefix, "combined")))
                else:
                    for ctx in ["CG", "CHG", "CHH"]:
                        stack_items.append(("meth", (gi, prefix, ctx)))
    # bam
    for gi, group in enumerate(name_layers):
        for nm in group:
            stack_items.append(("bam", (gi, nm, "")))
    if meth_position != "before" and meth_groups:
        for gi, group in enumerate(meth_groups):
            for prefix in group:
                if meth_layout == "combined":
                    stack_items.append(("meth", (gi, prefix, "combined")))
                else:
                    for ctx in ["CG", "CHG", "CHH"]:
                        stack_items.append(("meth", (gi, prefix, ctx)))

    total_tracks = len(stack_items)
    fig = plt.figure(figsize=(fig_x, fig_y), layout="constrained")

    # gene structure
    ax_gene = fig.add_axes([0.10, 0.96, 0.80, 0.03])
    plot_gene_structure_linear(ax_gene, model)
    # legend outside
    gene_handles = build_gene_legend_handles(model)
    if gene_handles:
        fig.legend(handles=gene_handles, loc="upper left", bbox_to_anchor=(0.92, 0.98), frameon=False)

    one_h = 0.95 / (total_tracks + 1)
    left = 0.10
    width = 0.80
    top_y = 0.95

    ax_list: List[plt.Axes] = []
    bam_color_idx = 0

    ylim_bam_global = parse_ylim(ylim)
    ylim_meth_global = parse_ylim(meth_ylim)

    for idx, (kind, (gi, name, ctxmode)) in enumerate(stack_items):
        rect = [left, top_y - (one_h + one_h / max(total_tracks, 1)) * (idx + 1), width, one_h]
        x_visible = (idx == total_tracks - 1)

        if kind == "bam":
            cov = bam_cov[gi][name]
            if ylim_bam_global is not None:
                yl = ylim_bam_global
            elif gi in bam_auto:
                yl = bam_auto[gi]
            else:
                yl = None
            ax = plot_one_bam_track(fig, rect, cov, name, bam_colors[bam_color_idx], x_visible=x_visible, ylim=yl)
            bam_color_idx += 1
            ax_list.append(ax)
        else:
            if not meth_dir:
                raise ValueError("meth_dir is required when meth tracks are requested.")
            d = load_meth_prefix(meth_dir, name, model["gene_id"], drop_me_zero=meth_drop_me_zero)

            if ctxmode == "combined":
                arrays = {ctx: meth_to_array(d[ctx], model["window_len"]) for ctx in ["CG", "CHG", "CHH"]}
                if ylim_meth_global is not None:
                    yl = ylim_meth_global
                elif gi in meth_auto:
                    yl = meth_auto[gi]
                else:
                    yl = (0.0, 1.0)
                ax = plot_one_meth_track(fig, rect, arrays,
                                         prefix=f"meth:{name}",
                                         layout="combined",
                                         colors=meth_colors,
                                         ylabel=meth_ylabel,
                                         show_prefix=meth_show_prefix,
                                         x_visible=x_visible,
                                         ylim=yl)
            else:
                arrays = {ctxmode: meth_to_array(d[ctxmode], model["window_len"])}
                if ylim_meth_global is not None:
                    yl = ylim_meth_global
                elif gi in meth_auto:
                    yl = meth_auto[gi]
                else:
                    yl = (0.0, 1.0)
                ax = plot_one_meth_track(fig, rect, arrays,
                                         prefix=f"meth:{name}:{ctxmode}",
                                         layout="separate",
                                         colors=meth_colors,
                                         ylabel=meth_ylabel,
                                         show_prefix=meth_show_prefix,
                                         x_visible=x_visible,
                                         ylim=yl)
            ax_list.append(ax)

    # x ticks on last axis
    ax_list[-1].set_xticks([0, dist, dist + gene_len, 2 * dist + gene_len])
    ax_list[-1].set_xticklabels([f"-{dist}", "TSS", "TTS", f"+{dist}"])

    fig.savefig(outpath, bbox_inches="tight")
    plt.close(fig)


def plot_3d(
    model: Dict,
    bam_cov: Dict[int, Dict[str, np.ndarray]],
    bam_layers: List[List[str]],
    name_layers: List[List[str]],
    *,
    outpath: str,
    fig_x: float = 10.0,
    fig_y: float = 10.0,
    cmap: str = "Set2",
    # 3D geometry
    base_left: float = 0.10,
    top_start: float = 0.95,
    width: float = 0.80,
    height: float = 0.12,
    x_off: float = 0.10,
    y_off: float = 0.60,
    layer_gap: float = 0.05,
    # y limits for bam
    ylim: Optional[str] = None,
    group_ylims: Optional[str] = None,
    share_group_ylim: bool = False,
    # methylation (added to 3D as additional tracks)
    meth_dir: Optional[str] = None,
    meth_spec: Optional[str] = None,
    meth_layout: str = "combined",
    meth_ylabel: str = "mC",
    meth_show_prefix: bool = True,
    meth_ylim: Optional[str] = None,
    meth_group_ylims: Optional[str] = None,
    meth_share_group_ylim: bool = False,
    meth_colors: Optional[Dict[str, str]] = None,
    meth_drop_me_zero: bool = True,
    meth_position: str = "after",  # before|after within each group
):
    dist = model["distance"]
    gene_len = model["gene_len"]

    # BAM colors follow flattened order of BAM labels
    bam_names_flat = flatten_layers(name_layers)
    bam_colors = get_colors(cmap, len(bam_names_flat))

    # Group ylims for BAM
    n_groups = len(name_layers)
    bam_group_ylims = parse_group_ylims(group_ylims, n_groups) if group_ylims else None
    bam_auto: Dict[int, Tuple[float, float]] = {}
    if share_group_ylim:
        for gi, group in enumerate(name_layers):
            arrs = [bam_cov[gi][nm] for nm in group]
            bam_auto[gi] = auto_group_ylim(arrs, pad=0.05, default=(0.0, 1.0))
    if bam_group_ylims is not None:
        for gi, yl in enumerate(bam_group_ylims):
            bam_auto[gi] = yl
    ylim_bam_global = parse_ylim(ylim)

    # Meth groups
    meth_groups = parse_layers(meth_spec) if meth_spec else []
    n_mg = len(meth_groups)
    meth_group_yl = parse_group_ylims(meth_group_ylims, n_mg) if (meth_group_ylims and n_mg > 0) else None
    meth_auto: Dict[int, Tuple[float, float]] = {}
    if meth_share_group_ylim and meth_groups and meth_dir:
        for gi, group in enumerate(meth_groups):
            arrs = []
            for prefix in group:
                d = load_meth_prefix(meth_dir, prefix, model["gene_id"], drop_me_zero=meth_drop_me_zero)
                for ctx in ["CG", "CHG", "CHH"]:
                    arrs.append(meth_to_array(d[ctx], model["window_len"]))
            meth_auto[gi] = auto_group_ylim(arrs, pad=0.05, default=(0.0, 1.0))
    if meth_group_yl is not None:
        for gi, yl in enumerate(meth_group_yl):
            meth_auto[gi] = yl
    ylim_meth_global = parse_ylim(meth_ylim)
    meth_colors = meth_colors or {"CG": "#FF3030", "CHG": "#00EE76", "CHH": "#00BFFF"}

    # Build a combined per-group track list for layout (track_id list)
    meta: Dict[str, Tuple[str, int, str, str]] = {}
    # track_id -> (kind, group_idx, name/prefix, ctxmode)
    combined_layers: List[List[str]] = []
    max_groups = max(len(name_layers), len(meth_groups)) if meth_groups else len(name_layers)

    for gi in range(max_groups):
        tids: List[str] = []
        bam_names = name_layers[gi] if gi < len(name_layers) else []
        meth_prefixes = meth_groups[gi] if gi < len(meth_groups) else []

        def add_meth():
            for pref in meth_prefixes:
                if meth_layout == "combined":
                    tid = f"meth:{pref}"
                    meta[tid] = ("meth", gi, pref, "combined")
                    tids.append(tid)
                else:
                    for ctx in ["CG", "CHG", "CHH"]:
                        tid = f"meth:{pref}:{ctx}"
                        meta[tid] = ("meth", gi, pref, ctx)
                        tids.append(tid)

        def add_bam():
            for nm in bam_names:
                tid = f"bam:{nm}"
                meta[tid] = ("bam", gi, nm, "")
                tids.append(tid)

        if meth_prefixes and meth_position == "before":
            add_meth()
            add_bam()
        else:
            add_bam()
            if meth_prefixes:
                add_meth()

        combined_layers.append(tids)

    spec = ";".join([",".join(x) for x in combined_layers])
    positions, used_w, used_h = get_track_positions_autoscale(
        spec,
        base_left=base_left,
        top_start=top_start,
        width=width,
        height=height,
        x_off=x_off,
        y_off=y_off,
        layer_gap=layer_gap,
        auto_scale=True,
    )

    fig = plt.figure(figsize=(fig_x, fig_y))

    # gene structure at top
    ax_gene = fig.add_axes([base_left, 0.96, used_w, 0.03])
    plot_gene_structure_linear(ax_gene, model)
    gene_handles = build_gene_legend_handles(model)
    if gene_handles:
        fig.legend(handles=gene_handles, loc="upper left", bbox_to_anchor=(0.92, 0.98), frameon=False)

    ax_list: List[plt.Axes] = []
    bam_color_idx = 0

    # plot tracks by positions
    for tid, rect, gi, idx_in_group in positions:
        kind, gidx, nm, ctxmode = meta[tid]

        if kind == "bam":
            cov = bam_cov[gidx][nm]
            if ylim_bam_global is not None:
                yl = ylim_bam_global
            elif gidx in bam_auto:
                yl = bam_auto[gidx]
            else:
                yl = None
            ax = plot_one_bam_track(fig, rect, cov, nm, bam_colors[bam_color_idx], x_visible=False, ylim=yl)
            bam_color_idx += 1
            ax_list.append(ax)
        else:
            if not meth_dir:
                raise ValueError("meth_dir is required when meth tracks are requested.")
            d = load_meth_prefix(meth_dir, nm, model["gene_id"], drop_me_zero=meth_drop_me_zero)

            if ctxmode == "combined":
                arrays = {ctx: meth_to_array(d[ctx], model["window_len"]) for ctx in ["CG", "CHG", "CHH"]}
                if ylim_meth_global is not None:
                    yl = ylim_meth_global
                elif gidx in meth_auto:
                    yl = meth_auto[gidx]
                else:
                    yl = (0.0, 1.0)
                ax = plot_one_meth_track(fig, rect, arrays,
                                         prefix=f"meth:{nm}",
                                         layout="combined",
                                         colors=meth_colors,
                                         ylabel=meth_ylabel,
                                         show_prefix=meth_show_prefix,
                                         x_visible=False,
                                         ylim=yl)
                ax_list.append(ax)
            else:
                arrays = {ctxmode: meth_to_array(d[ctxmode], model["window_len"])}
                if ylim_meth_global is not None:
                    yl = ylim_meth_global
                elif gidx in meth_auto:
                    yl = meth_auto[gidx]
                else:
                    yl = (0.0, 1.0)
                ax = plot_one_meth_track(fig, rect, arrays,
                                         prefix=f"meth:{nm}:{ctxmode}",
                                         layout="separate",
                                         colors=meth_colors,
                                         ylabel=meth_ylabel,
                                         show_prefix=meth_show_prefix,
                                         x_visible=False,
                                         ylim=yl)
                ax_list.append(ax)

    # x tick labels: last axis of each group gets x tick labels
    # We rely on combined_layers lengths to compute indices
    cum = np.cumsum([0] + [len(x) for x in combined_layers])
    for gi in range(len(combined_layers)):
        if len(combined_layers[gi]) == 0:
            continue
        ax_last = ax_list[int(cum[gi+1]) - 1]
        ax_last.set_xticks([0, dist, dist + gene_len, 2 * dist + gene_len])
        ax_last.set_xticklabels([f"-{dist}", "TSS", "TTS", f"+{dist}"])
        plt.setp(ax_last.get_xticklabels(), visible=True)

    # add inside vertical guides and between-axes connectors (per group)
    xs = [dist, dist + gene_len]
    for ax in ax_list:
        add_inside_xlines(ax, xs, zorder=1)

    for gi in range(len(combined_layers)):
        start = int(cum[gi])
        end = int(cum[gi+1])
        if end - start <= 1:
            continue
        grp_axes = ax_list[start:end]
        for j in range(len(grp_axes) - 1):
            for xpos in xs:
                connect_vertical(xpos, grp_axes[j], grp_axes[j + 1])

    fig.savefig(outpath, bbox_inches="tight")
    plt.close(fig)


# -----------------------------
# CLI
# -----------------------------


def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(
        prog="omicscanvas_gene_tracks_2d3d.py",
        formatter_class=argparse.RawTextHelpFormatter,
        description=(
            "OmicsCanvas | Single-gene tracks (2D / 3D)\n\n"
            "This script draws per-gene stacked tracks from:\n"
            "  (1) Gene model (GFF3)\n"
            "  (2) BAM tracks (ChIP/Input/RNA, etc.)\n"
            "  (3) Optional methylation TSV tracks (CG/CHG/CHH, per-prefix)\n\n"
            "Layer syntax used by --bam-spec / --name-spec / --meth-spec:\n"
            "  - ';' separates groups (each group becomes a row of tracks)\n"
            "  - ',' separates tracks within the same group\n\n"
            "Examples:\n"
            "  # 2D stacked tracks (BAM only)\n"
            "  python omicscanvas_gene_tracks_2d3d.py \\\n"
            "    --mode 2d --gff3 genome.gff3 --gene GeneX \\\n"
            "    --bam-dir bam --bam-spec 'A.bam,B.bam;Input.bam' \\\n"
            "    --name-spec 'H3K27me3,H3K36me3;Input' \\\n"
            "    --distance 2000 --out GeneX_2d.pdf\n\n"
            "  # 3D pseudo-3D tracks + methylation (after BAM)\n"
            "  python omicscanvas_gene_tracks_2d3d.py \\\n"
            "    --mode 3d --gff3 genome.gff3 --gene GeneX \\\n"
            "    --bam-dir bam --bam-spec 'A.bam,B.bam;Input.bam' \\\n"
            "    --name-spec 'H3K27me3,H3K36me3;Input' \\\n"
            "    --meth-dir CX_gene --meth-spec 'SRRxxx__GeneX' --meth-layout combined \\\n"
            "    --meth-position after --distance 2000 --out GeneX_3d.pdf\n"
        ),
    )

    # ---------- Core output ----------
    p.add_argument(
        "--mode",
        choices=["2d", "3d"],
        required=True,
        help=(
            "Plot mode.\n"
            "  2d: classic stacked tracks.\n"
            "  3d: pseudo-3D stacked offset tracks (use --x-off/--y-off to control depth)."
        ),
    )
    p.add_argument(
        "--out",
        required=True,
        help=(
            "Output figure path. File extension controls format (e.g. .pdf, .png, .svg)."
        ),
    )

    # ---------- Gene model ----------
    p.add_argument("--gff3", required=True, help="GFF3 annotation file.")
    p.add_argument(
        "--gene",
        required=True,
        help=(
            "Target gene/transcript ID. Must match the mRNA feature ID in the GFF3 (as used in your workflow)."
        ),
    )
    p.add_argument(
        "--distance",
        type=int,
        default=1000,
        help=(
            "Upstream/downstream window in bp. The plotted window is [gene_start-distance, gene_end+distance]."
        ),
    )
    p.add_argument(
        "--gene-keywords",
        default="ID",
        help=(
            "GFF3 attribute key used to read the mRNA ID (default: ID)."
        ),
    )
    p.add_argument(
        "--exon-keywords",
        default="Parent",
        help=(
            "GFF3 attribute key used to link exon/CDS/UTR to the parent transcript (default: Parent)."
        ),
    )

    # ---------- BAM tracks ----------
    p.add_argument(
        "--bam-spec",
        required=True,
        help=(
            "BAM files arranged by layers. Example: 'A.bam,B.bam;Input.bam'.\n"
            "Semicolon = group (row); comma = track within group."
        ),
    )
    p.add_argument(
        "--name-spec",
        required=True,
        help=(
            "Track labels with the same ';' and ',' structure as --bam-spec.\n"
            "Example: 'H3K27me3,H3K36me3;Input'."
        ),
    )
    p.add_argument(
        "--bam-dir",
        default=".",
        help="Directory containing BAM files (used if entries in --bam-spec are relative paths).",
    )
    p.add_argument(
        "--reads-length",
        type=int,
        default=150,
        help=(
            "Read length (bp) for coverage normalization. Keep consistent with your BAM sequencing read length."
        ),
    )
    p.add_argument(
        "--seq-type",
        choices=["paired", "single"],
        default="paired",
        help="BAM sequencing type used for normalization (paired-end or single-end).",
    )

    # ---------- Figure ----------
    p.add_argument("--fig-x", type=float, default=10.0, help="Figure width (inches).")
    p.add_argument("--fig-y", type=float, default=10.0, help="Figure height (inches).")
    p.add_argument(
        "--cmap",
        default="Set2",
        help=(
            "Matplotlib colormap for BAM lines. Colors are sampled from this cmap for tracks in each group."
        ),
    )

    # ---------- Y-axis controls (BAM) ----------
    p.add_argument(
        "--ylim",
        default=None,
        help=(
            "Global y-axis range for ALL BAM tracks: 'ymin,ymax'. Example: --ylim 0,5\n"
            "If not provided, each track/group is auto-scaled unless --share-group-ylim is used."
        ),
    )
    p.add_argument(
        "--group-ylims",
        default=None,
        help=(
            "Per-group y-axis range for BAM (one 'ymin,ymax' per ';' group),\n"
            "Example: --group-ylims '0,5;0,2'."
        ),
    )
    p.add_argument(
        "--share-group-ylim",
        action="store_true",
        help=(
            "Auto-compute a single shared ylim within each ';' group (useful to compare tracks inside a group)."
        ),
    )

    # ---------- 3D layout (only used when --mode 3d) ----------
    p.add_argument(
        "--x-off",
        type=float,
        default=0.10,
        help=(
            "3D: x offset factor between successive groups (depth). Effective shift = x_off * track_width."
        ),
    )
    p.add_argument(
        "--y-off",
        type=float,
        default=0.60,
        help=(
            "3D: y offset factor between successive groups (depth). Effective shift = y_off * track_height."
        ),
    )
    p.add_argument(
        "--layer-gap",
        type=float,
        default=0.05,
        help="3D: additional vertical gap between ';' groups (fraction of figure height).",
    )
    p.add_argument(
        "--track-width",
        type=float,
        default=0.80,
        help="3D: base track width (figure fraction).",
    )
    p.add_argument(
        "--track-height",
        type=float,
        default=0.12,
        help="3D: base track height (figure fraction).",
    )
    p.add_argument("--base-left", type=float, default=0.10, help="3D: left margin for the first group.")
    p.add_argument("--top-start", type=float, default=0.95, help="3D: top anchor for the first group.")

    # ---------- Optional methylation tracks (linear) ----------
    p.add_argument("--meth-dir", default=None, help="Directory containing methylation TSV files.")
    p.add_argument(
        "--meth-spec",
        default=None,
        help=(
            "Methylation prefixes arranged by layers (same ';' and ',' syntax).\n"
            "Each prefix loads three files: <prefix>__CG.tsv, <prefix>__CHG.tsv, <prefix>__CHH.tsv."
        ),
    )
    p.add_argument(
        "--meth-layout",
        choices=["combined", "separate"],
        default="combined",
        help=(
            "Methylation layout in 2D/3D:\n"
            "  combined: overlay CG/CHG/CHH in one axis (colors fixed in code).\n"
            "  separate: draw three axes per prefix (CHH/CHG/CG)."
        ),
    )
    p.add_argument(
        "--meth-ylabel",
        default="mC",
        help="Short y-axis label for methylation tracks.",
    )
    p.add_argument(
        "--meth-hide-prefix",
        action="store_true",
        help="If set, do NOT print the methylation prefix as small text inside the axis.",
    )
    p.add_argument(
        "--meth-ylim",
        default=None,
        help="Global y-axis range for methylation tracks: 'ymin,ymax'.",
    )
    p.add_argument(
        "--meth-group-ylims",
        default=None,
        help="Per-group y-axis range for methylation (one per ';' group): 'ymin,ymax;ymin,ymax'.",
    )
    p.add_argument(
        "--meth-share-group-ylim",
        action="store_true",
        help="Auto share the same ylim within each methylation ';' group.",
    )
    p.add_argument(
        "--meth-drop-me-zero",
        action="store_true",
        help="When reading methylation TSVs, drop rows with me==0 (helps reduce noise from empty bins).",
    )
    p.add_argument(
        "--meth-position",
        choices=["before", "after"],
        default="after",
        help=(
            "Where to place methylation tracks relative to BAM tracks (only when methylation is enabled).\n"
            "  before: methylation rows before BAM rows\n"
            "  after : methylation rows after BAM rows"
        ),
    )

    return p.parse_args(argv)


def validate_args(args: argparse.Namespace) -> None:
    bam_layers = parse_layers(args.bam_spec)
    name_layers = parse_layers(args.name_spec)
    if len(bam_layers) != len(name_layers):
        raise ValueError("--bam-spec and --name-spec must have the same number of ';' groups.")
    for gi in range(len(bam_layers)):
        if len(bam_layers[gi]) != len(name_layers[gi]):
            raise ValueError(f"Group {gi}: BAM count != name count. Check commas in --bam-spec/--name-spec.")

    if args.meth_spec and (not args.meth_dir):
        raise ValueError("--meth-dir is required when --meth-spec is provided.")

    if pysam is None:
        raise RuntimeError(
            "pysam is required to read BAM files. Install it via: conda install -c bioconda pysam"
        )


def main(argv: Optional[List[str]] = None) -> None:
    args = parse_args(argv)
    validate_args(args)

    gff = load_gff3(args.gff3)
    model = build_gene_model(
        gff,
        args.gene,
        gene_keywords=args.gene_keywords,
        exon_keywords=args.exon_keywords,
        distance=args.distance,
    )

    bam_layers = parse_layers(args.bam_spec)
    name_layers = parse_layers(args.name_spec)
    bam_cov = build_bam_cov(
        model,
        bam_layers,
        name_layers,
        args.bam_dir,
        args.reads_length,
        args.seq_type,
    )

    meth_show_prefix = (not args.meth_hide_prefix)

    if args.mode == "2d":
        plot_2d(
            model,
            bam_cov,
            name_layers,
            outpath=args.out,
            fig_x=args.fig_x,
            fig_y=args.fig_y,
            cmap=args.cmap,
            ylim=args.ylim,
            group_ylims=args.group_ylims,
            share_group_ylim=args.share_group_ylim,
            meth_dir=args.meth_dir,
            meth_spec=args.meth_spec,
            meth_layout=args.meth_layout,
            meth_ylabel=args.meth_ylabel,
            meth_show_prefix=meth_show_prefix,
            meth_ylim=args.meth_ylim,
            meth_group_ylims=args.meth_group_ylims,
            meth_share_group_ylim=args.meth_share_group_ylims,
            meth_drop_me_zero=args.meth_drop_me_zero,
            meth_position=args.meth_position,
        )
    else:
        plot_3d(
            model,
            bam_cov,
            bam_layers,
            name_layers,
            outpath=args.out,
            fig_x=args.fig_x,
            fig_y=args.fig_y,
            cmap=args.cmap,
            base_left=args.base_left,
            top_start=args.top_start,
            width=args.track_width,
            height=args.track_height,
            x_off=args.x_off,
            y_off=args.y_off,
            layer_gap=args.layer_gap,
            ylim=args.ylim,
            group_ylims=args.group_ylims,
            share_group_ylim=args.share_group_ylim,
            meth_dir=args.meth_dir,
            meth_spec=args.meth_spec,
            meth_layout=args.meth_layout,
            meth_ylabel=args.meth_ylabel,
            meth_show_prefix=meth_show_prefix,
            meth_ylim=args.meth_ylim,
            meth_group_ylims=args.meth_group_ylims,
            meth_share_group_ylim=args.meth_share_group_ylims,
            meth_drop_me_zero=args.meth_drop_me_zero,
            meth_position=args.meth_position,
        )


if __name__ == "__main__":
    main()
